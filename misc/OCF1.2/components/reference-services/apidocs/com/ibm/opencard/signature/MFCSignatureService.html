<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Thu Dec 02 15:53:49 GMT+01:00 1999 -->
<TITLE>
: Class  MFCSignatureService
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" ID="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT ID="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="package-summary.html"><FONT ID="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" ID="NavBarCell1Rev"> &nbsp;<FONT ID="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="package-tree.html"><FONT ID="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT ID="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT ID="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT ID="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" ID="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../com/ibm/opencard/signature/MFCSignatureParameter.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" ID="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="MFCSignatureService.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" ID="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" ID="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
com.ibm.opencard.signature</FONT>
<BR>
Class  MFCSignatureService</H2>
<PRE>
java.lang.Object
  |
  +--opencard.core.service.CardService
        |
        +--<A HREF="../../../../com/ibm/opencard/service/MFCCardService.html">com.ibm.opencard.service.MFCCardService</A>
              |
              +--<B>com.ibm.opencard.signature.MFCSignatureService</B>
</PRE>
<HR>
<DL>
<DT>public class <B>MFCSignatureService</B><DT>extends <A HREF="../../../../com/ibm/opencard/service/MFCCardService.html">MFCCardService</A><DT>implements opencard.opt.signature.SignatureCardService</DL>

<P>
<tt>MFCSignatureService</tt> extends the common base class
 <tt>MFCCardService</tt> of all MFC card services and implements the
 <tt>SignatureCardService</tt> interface defined by OCF.
 <tt>MFCSignatureService</tt> serves as the base class of all IBM
 MFC-based <tt>SignatureCardService</tt> implementations.<p>

 Instances of <tt>MFCSignatureService</tt> or one of its
 subclasses, which talk to a specific physical smart card, delegate
 execution of the functionality defined in <tt>SignatureCardService</tt>
 to a (singleton) driver for that card, which implements interface
 <tt>MFCSignatureImpl</tt> for a specific card.
<P>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../../../com/ibm/opencard/service/MFCCardService.html"><CODE>MFCCardService</CODE></A>, 
<CODE>SignatureCardService</CODE></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" ID="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../com/ibm/opencard/signature/MFCKeyInfoRParser.html">MFCKeyInfoRParser</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#kiParser">kiParser</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../com/ibm/opencard/signature/MFCSignatureImpl.html">MFCSignatureImpl</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#sigImpl">sigImpl</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instances of <tt>MFCSignatureService</tt>s share a single instance
 of a card service implementation class implementing <tt>MFCSignatureImpl</tt>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_com.ibm.opencard.service.MFCCardService"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" ID="TableSubHeadingColor">
<TD><B>Fields inherited from class com.ibm.opencard.service.<A HREF="../../../../com/ibm/opencard/service/MFCCardService.html">MFCCardService</A></B></TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD><CODE><A HREF="../../../../com/ibm/opencard/service/MFCCardService.html#card_type">card_type</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" ID="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#MFCSignatureService()">MFCSignatureService</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a new signature service for MFC smartcards.
 </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" ID="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#initialize(opencard.core.service.CardServiceScheduler, opencard.core.service.SmartCard, boolean)">initialize</A></B>(opencard.core.service.CardServiceScheduler&nbsp;scheduler,
           opencard.core.service.SmartCard&nbsp;smartcard,
           boolean&nbsp;blocking)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes this service.
 </TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#initSignature(com.ibm.opencard.signature.MFCSignatureParameter)">initSignature</A></B>(<A HREF="../../../../com/ibm/opencard/signature/MFCSignatureParameter.html">MFCSignatureParameter</A>&nbsp;parameter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes this service from encapsulated parameters.
 </TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#satisfyAccessConditions(com.ibm.opencard.signature.MFCKeyInfo)">satisfyAccessConditions</A></B>(<A HREF="../../../../com/ibm/opencard/signature/MFCKeyInfo.html">MFCKeyInfo</A>&nbsp;ki)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;satisfy access conditions.
 </TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#signData(opencard.opt.security.PrivateKeyRef, java.lang.String, byte[])">signData</A></B>(opencard.opt.security.PrivateKeyRef&nbsp;privateKey,
         java.lang.String&nbsp;signAlgorithm,
         byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate a digital Signature.
 </TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#signData(opencard.opt.security.PrivateKeyRef, java.lang.String, java.lang.String, byte[])">signData</A></B>(opencard.opt.security.PrivateKeyRef&nbsp;privateKey,
         java.lang.String&nbsp;signAlgorithm,
         java.lang.String&nbsp;padAlgorithm,
         byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overloaded method to generate a digital Signature
 that allows to specify the padding algorithm.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#signDataInternal(opencard.opt.security.PrivateKeyRef, java.lang.String, java.lang.String, byte[])">signDataInternal</A></B>(opencard.opt.security.PrivateKeyRef&nbsp;privateKey,
                 java.lang.String&nbsp;signAlgorithm,
                 java.lang.String&nbsp;padAlgorithm,
                 byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calculate hash and generate signatre</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#signHash(opencard.opt.security.PrivateKeyRef, java.lang.String, byte[])">signHash</A></B>(opencard.opt.security.PrivateKeyRef&nbsp;privateKey,
         java.lang.String&nbsp;signAlgorithm,
         byte[]&nbsp;hash)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate a digital Signature on the provided hash.
 </TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#signHash(opencard.opt.security.PrivateKeyRef, java.lang.String, java.lang.String, byte[])">signHash</A></B>(opencard.opt.security.PrivateKeyRef&nbsp;privateKey,
         java.lang.String&nbsp;signAlgorithm,
         java.lang.String&nbsp;padAlgorithm,
         byte[]&nbsp;hash)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Overloaded method to generate a digital Signature
 that allows to specify the padding algorithm.</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#signHashInternal(opencard.opt.security.PrivateKeyRef, java.lang.String, java.lang.String, byte[])">signHashInternal</A></B>(opencard.opt.security.PrivateKeyRef&nbsp;privateKey,
                 java.lang.String&nbsp;signAlgorithm,
                 java.lang.String&nbsp;padAlgorithm,
                 byte[]&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;generate signature on the provided hash</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#verifySignedData(opencard.opt.security.PublicKeyRef, java.lang.String, byte[], byte[])">verifySignedData</A></B>(opencard.opt.security.PublicKeyRef&nbsp;publicKey,
                 java.lang.String&nbsp;signAlgorithm,
                 byte[]&nbsp;data,
                 byte[]&nbsp;signature)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verify a digital Signature including hashing.
 </TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#verifySignedData(opencard.opt.security.PublicKeyRef, java.lang.String, java.lang.String, byte[], byte[])">verifySignedData</A></B>(opencard.opt.security.PublicKeyRef&nbsp;publicKey,
                 java.lang.String&nbsp;signAlgorithm,
                 java.lang.String&nbsp;padAlgorithm,
                 byte[]&nbsp;data,
                 byte[]&nbsp;signature)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verify a digital Signature including hashing
 (overload method that allows to specify the padding algorithm to be used).
 </TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#verifySignedDataInternal(opencard.opt.security.PublicKeyRef, java.lang.String, java.lang.String, byte[], byte[])">verifySignedDataInternal</A></B>(opencard.opt.security.PublicKeyRef&nbsp;publicKey,
                         java.lang.String&nbsp;signAlgorithm,
                         java.lang.String&nbsp;padAlgorithm,
                         byte[]&nbsp;data,
                         byte[]&nbsp;signature)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calculate hash and verify signature</TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#verifySignedHash(opencard.opt.security.PublicKeyRef, java.lang.String, byte[], byte[])">verifySignedHash</A></B>(opencard.opt.security.PublicKeyRef&nbsp;publicKey,
                 java.lang.String&nbsp;signAlgorithm,
                 byte[]&nbsp;hash,
                 byte[]&nbsp;signature)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verify a digital Signature.
 </TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#verifySignedHash(opencard.opt.security.PublicKeyRef, java.lang.String, java.lang.String, byte[], byte[])">verifySignedHash</A></B>(opencard.opt.security.PublicKeyRef&nbsp;publicKey,
                 java.lang.String&nbsp;signAlgorithm,
                 java.lang.String&nbsp;padAlgorithm,
                 byte[]&nbsp;hash,
                 byte[]&nbsp;signature)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verify a digital Signature
 (overloaded method that allows to specify the padding algorithm to be used).
 </TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#verifySignedHashInternal(opencard.opt.security.PublicKeyRef, java.lang.String, java.lang.String, byte[], byte[])">verifySignedHashInternal</A></B>(opencard.opt.security.PublicKeyRef&nbsp;publicKey,
                         java.lang.String&nbsp;signAlgorithm,
                         java.lang.String&nbsp;padAlgorithm,
                         byte[]&nbsp;hash,
                         byte[]&nbsp;signature)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;verify signature for given hash</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_com.ibm.opencard.service.MFCCardService"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" ID="TableSubHeadingColor">
<TD><B>Methods inherited from class com.ibm.opencard.service.<A HREF="../../../../com/ibm/opencard/service/MFCCardService.html">MFCCardService</A></B></TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD><CODE><A HREF="../../../../com/ibm/opencard/service/MFCCardService.html#allocateCardChannel()">allocateCardChannel</A>, 
<A HREF="../../../../com/ibm/opencard/service/MFCCardService.html#checkFileArg(opencard.opt.iso.fs.CardFilePath)">checkFileArg</A>, 
<A HREF="../../../../com/ibm/opencard/service/MFCCardService.html#getMFCChannel()">getMFCChannel</A>, 
<A HREF="../../../../com/ibm/opencard/service/MFCCardService.html#getRoot()">getRoot</A>, 
<A HREF="../../../../com/ibm/opencard/service/MFCCardService.html#initGeneric(com.ibm.opencard.service.MFCCardServiceParameter)">initGeneric</A>, 
<A HREF="../../../../com/ibm/opencard/service/MFCCardService.html#provideCredentials(opencard.opt.security.SecurityDomain, opencard.opt.security.CredentialBag)">provideCredentials</A>, 
<A HREF="../../../../com/ibm/opencard/service/MFCCardService.html#releaseCardChannel()">releaseCardChannel</A>, 
<A HREF="../../../../com/ibm/opencard/service/MFCCardService.html#selectObject(com.ibm.opencard.service.MFCCardChannel, opencard.opt.iso.fs.CardFilePath, boolean)">selectObject</A>, 
<A HREF="../../../../com/ibm/opencard/service/MFCCardService.html#setCHVDialog(opencard.core.service.CHVDialog)">setCHVDialog</A>, 
<A HREF="../../../../com/ibm/opencard/service/MFCCardService.html#setParentChannel(com.ibm.opencard.service.MFCCardChannel)">setParentChannel</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_opencard.core.service.CardService"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" ID="TableSubHeadingColor">
<TD><B>Methods inherited from class opencard.core.service.CardService</B></TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD><CODE>getCard, 
getCardChannel, 
getCHVDialog, 
setCardChannel</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" ID="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" ID="TableRowColor">
<TD><CODE>clone, 
equals, 
finalize, 
getClass, 
hashCode, 
notify, 
notifyAll, 
toString, 
wait, 
wait, 
wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" ID="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="sigImpl"><!-- --></A><H3>
sigImpl</H3>
<PRE>
protected <A HREF="../../../../com/ibm/opencard/signature/MFCSignatureImpl.html">MFCSignatureImpl</A> <B>sigImpl</B></PRE>
<DL>
<DD>Instances of <tt>MFCSignatureService</tt>s share a single instance
 of a card service implementation class implementing <tt>MFCSignatureImpl</tt>.</DL>
<HR>

<A NAME="kiParser"><!-- --></A><H3>
kiParser</H3>
<PRE>
protected <A HREF="../../../../com/ibm/opencard/signature/MFCKeyInfoRParser.html">MFCKeyInfoRParser</A> <B>kiParser</B></PRE>
<DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" ID="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="MFCSignatureService()"><!-- --></A><H3>
MFCSignatureService</H3>
<PRE>
public <B>MFCSignatureService</B>()</PRE>
<DL>
<DD>Creates a new signature service for MFC smartcards.
 The service cannot be used until it has been initialized by invoking
 <tt>initialize</tt>. If this service has to be initialized as part
 of a derived service, <tt>initSignature</tt> has to be invoked instead.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#initialize(opencard.core.service.CardServiceScheduler, opencard.core.service.SmartCard, boolean)"><CODE>initialize(opencard.core.service.CardServiceScheduler, opencard.core.service.SmartCard, boolean)</CODE></A>, 
<A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#initSignature(com.ibm.opencard.signature.MFCSignatureParameter)"><CODE>initSignature(com.ibm.opencard.signature.MFCSignatureParameter)</CODE></A></DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" ID="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="initialize(opencard.core.service.CardServiceScheduler, opencard.core.service.SmartCard, boolean)"><!-- --></A><H3>
initialize</H3>
<PRE>
protected void <B>initialize</B>(opencard.core.service.CardServiceScheduler&nbsp;scheduler,
                          opencard.core.service.SmartCard&nbsp;smartcard,
                          boolean&nbsp;blocking)
                   throws opencard.core.service.CardServiceException</PRE>
<DL>
<DD>Initializes this service.
 This is an entry point for initializing the MFC signature service.
 It invokes <tt>initSignature</tt> to perform the actual initialization.
 Derived services must not invoke this method, but have to invoke
 <tt>initSignature</tt> directly.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scheduler</CODE> - where to allocate channels<DD><CODE>smartcard</CODE> - which smartcard to contact<DD><CODE>blocking</CODE> - whether operation shall be blocking<DT><B>Throws:</B><DD>opencard.core.service.CardServiceException - initialization failed<DT><B>Overrides:</B><DD><A HREF="../../../../com/ibm/opencard/service/MFCCardService.html#initialize(opencard.core.service.CardServiceScheduler, opencard.core.service.SmartCard, boolean)">initialize</A> in class <A HREF="../../../../com/ibm/opencard/service/MFCCardService.html">MFCCardService</A><DT><B>See Also: </B><DD><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureService.html#initSignature(com.ibm.opencard.signature.MFCSignatureParameter)"><CODE>initSignature(com.ibm.opencard.signature.MFCSignatureParameter)</CODE></A>, 
<A HREF="../../../../com/ibm/opencard/service/MFCCardService.html#initialize(opencard.core.service.CardServiceScheduler, opencard.core.service.SmartCard, boolean)"><CODE>MFCCardService.initialize(opencard.core.service.CardServiceScheduler, opencard.core.service.SmartCard, boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="initSignature(com.ibm.opencard.signature.MFCSignatureParameter)"><!-- --></A><H3>
initSignature</H3>
<PRE>
public final void <B>initSignature</B>(<A HREF="../../../../com/ibm/opencard/signature/MFCSignatureParameter.html">MFCSignatureParameter</A>&nbsp;parameter)
                         throws opencard.core.service.CardServiceException</PRE>
<DL>
<DD>Initializes this service from encapsulated parameters.
 This method initializes the local attributes and invokes
 <tt>initGeneric</tt> in the base class.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>parameter</CODE> - an object encapsulating the parameters to this service<DT><B>Throws:</B><DD>opencard.core.service.CardServiceException - if the initialization failed.
            With the current implementation, this cannot happen.<DT><B>See Also: </B><DD><A HREF="../../../../com/ibm/opencard/signature/MFCSignatureParameter.html"><CODE>MFCSignatureParameter</CODE></A>, 
<A HREF="../../../../com/ibm/opencard/service/MFCCardService.html#initGeneric(com.ibm.opencard.service.MFCCardServiceParameter)"><CODE>MFCCardService.initGeneric(com.ibm.opencard.service.MFCCardServiceParameter)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="satisfyAccessConditions(com.ibm.opencard.signature.MFCKeyInfo)"><!-- --></A><H3>
satisfyAccessConditions</H3>
<PRE>
protected void <B>satisfyAccessConditions</B>(<A HREF="../../../../com/ibm/opencard/signature/MFCKeyInfo.html">MFCKeyInfo</A>&nbsp;ki)
                                throws opencard.core.service.CardServiceException,
                                       opencard.core.terminal.CardTerminalException</PRE>
<DL>
<DD>satisfy access conditions.
 Access conditions must be satisfied before calculating the hash.
 beetween calculating the hash and generating the signature no other
 command may be sent to the card.
 The trick is to send a generateSignature command to the card using a hash key.
 The MFCCardAccessor will retry the command until the access conditions are
 satisfied and then a rc 69 85 (the key is a hash key) is expected.<DD><DL>
<DT><B>Throws:</B><DD>opencard.core.service.CardServiceException - any subclass of CardServiceException<DD>opencard.core.terminal.CardTerminalException - any subclass of CardTerminalException</DL>
</DD>
</DL>
<HR>

<A NAME="signData(opencard.opt.security.PrivateKeyRef, java.lang.String, byte[])"><!-- --></A><H3>
signData</H3>
<PRE>
public byte[] <B>signData</B>(opencard.opt.security.PrivateKeyRef&nbsp;privateKey,
                       java.lang.String&nbsp;signAlgorithm,
                       byte[]&nbsp;data)
                throws opencard.core.service.CardServiceException,
                       java.security.InvalidKeyException,
                       opencard.core.terminal.CardTerminalException</PRE>
<DL>
<DD>Generate a digital Signature.
 First hash the data, then pad the hash and then
 apply the PKA algorithm to the padded hash.
 <p>
 The padding algorithm is chosen as defined in the Java Cryptography Architecture Specification.
 SHA1withRSA: PKCS#1 padding.
 SHA1withDSA: currently JCA does not specify the padding, thus the padding defined in the key is
              implicitly being used
 <p>
 The standard algorithm name must be specified as defined in the 
 Java Cryptography Architecture API Specification & Reference,
 for example
 <DL COMPACT>
 <DT>MD5withRSA<DD>The Signature algorithm obtained by combining the RSA
                   AsymmetricCipher algorithm with the MD5 MessageDigest Algorithm.
 <DT>MD2withRSA<DD>The Signature algorithm obtained by combining the RSA
                   AsymmetricCipher algorithm with the MD2 MessageDigest Algorithm.
 <DT>SHA1withRSA<DD>The Signature algorithm obtained by combining the RSA
                    AsymmetricCipher algorithm with the SHA-1 MessageDigest Algorithm.
 <DT>SHA1withDSA<DD>Digital Signature Algorithm, as defined in Digital Signature Standard,
                    NIST FIPS 186.  This standard defines a digital signature algorithm
                    that uses the RawDSA asymmetric transformation along with the SHA-1
                    message digest algorithm.
 </DL><DD><DL>
<DT><B>Specified by: </B><DD>signData in interface opencard.opt.signature.SignatureCardService<DT><B>Parameters:</B><DD><CODE>privateKey</CODE> - a reference to the private key on card to be used for signing.
         MFC cards only support key references of type PrivateKeyFile.<DD><CODE>signAlgorithm</CODE> - standard digital signature algorithm name<DD><CODE>data</CODE> - data to be signed<DT><B>Returns:</B><DD>signature<DT><B>Throws:</B><DD>java.security.InvalidKeyException - Thrown when the key is not valid or does not match the requested algorithm.<DD>opencard.core.service.CardServiceException - any subclass of CardServiceException<DD>opencard.core.terminal.CardTerminalException - any subclass of CardTerminalException<DT><B>See Also: </B><DD><CODE>JCAStandardNames</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="signData(opencard.opt.security.PrivateKeyRef, java.lang.String, java.lang.String, byte[])"><!-- --></A><H3>
signData</H3>
<PRE>
public byte[] <B>signData</B>(opencard.opt.security.PrivateKeyRef&nbsp;privateKey,
                       java.lang.String&nbsp;signAlgorithm,
                       java.lang.String&nbsp;padAlgorithm,
                       byte[]&nbsp;data)
                throws opencard.core.service.CardServiceException,
                       java.security.InvalidKeyException,
                       opencard.core.terminal.CardTerminalException</PRE>
<DL>
<DD>Overloaded method to generate a digital Signature
 that allows to specify the padding algorithm.<DD><DL>
<DT><B>Specified by: </B><DD>signData in interface opencard.opt.signature.SignatureCardService<DT><B>Throws:</B><DD>java.security.InvalidKeyException - The key type is not supported by the specific card service.<DD>opencard.core.service.CardServiceException - any subclass of CardServiceException<DD>opencard.core.terminal.CardTerminalException - any subclass of CardTerminalException</DL>
</DD>
</DL>
<HR>

<A NAME="signDataInternal(opencard.opt.security.PrivateKeyRef, java.lang.String, java.lang.String, byte[])"><!-- --></A><H3>
signDataInternal</H3>
<PRE>
protected byte[] <B>signDataInternal</B>(opencard.opt.security.PrivateKeyRef&nbsp;privateKey,
                                  java.lang.String&nbsp;signAlgorithm,
                                  java.lang.String&nbsp;padAlgorithm,
                                  byte[]&nbsp;data)
                           throws opencard.core.service.CardServiceException,
                                  java.security.InvalidKeyException,
                                  opencard.core.terminal.CardTerminalException</PRE>
<DL>
<DD>calculate hash and generate signatre<DD><DL>
<DT><B>Parameters:</B><DD><CODE>padAlgorithm</CODE> - If specified, check whether the card and the key support the pad algorithm.
                     If not specified, use the key's pad algorithm<DT><B>Throws:</B><DD>java.security.InvalidKeyException - The key type is not supported by the specific card service.<DD>opencard.core.service.CardServiceException - any subclass of CardServiceException<DD>opencard.core.terminal.CardTerminalException - any subclass of CardTerminalException</DL>
</DD>
</DL>
<HR>

<A NAME="signHash(opencard.opt.security.PrivateKeyRef, java.lang.String, byte[])"><!-- --></A><H3>
signHash</H3>
<PRE>
public byte[] <B>signHash</B>(opencard.opt.security.PrivateKeyRef&nbsp;privateKey,
                       java.lang.String&nbsp;signAlgorithm,
                       byte[]&nbsp;hash)
                throws opencard.core.service.CardServiceException,
                       java.security.InvalidKeyException,
                       opencard.core.terminal.CardTerminalException</PRE>
<DL>
<DD>Generate a digital Signature on the provided hash.
 Pad the hash and then
 apply the PKA algorithm to the padded hash.
 The padding algorithm is chosen as defined in the Java Cryptography Architecture Specification.<DD><DL>
<DT><B>Specified by: </B><DD>signHash in interface opencard.opt.signature.SignatureCardService<DT><B>Throws:</B><DD>java.security.InvalidKeyException - Thrown when the key is not valid or does not match the requested algorithm.<DD>opencard.core.service.CardServiceException - any subclass of CardServiceException<DD>opencard.core.terminal.CardTerminalException - any subclass of CardTerminalException</DL>
</DD>
</DL>
<HR>

<A NAME="signHash(opencard.opt.security.PrivateKeyRef, java.lang.String, java.lang.String, byte[])"><!-- --></A><H3>
signHash</H3>
<PRE>
public byte[] <B>signHash</B>(opencard.opt.security.PrivateKeyRef&nbsp;privateKey,
                       java.lang.String&nbsp;signAlgorithm,
                       java.lang.String&nbsp;padAlgorithm,
                       byte[]&nbsp;hash)
                throws opencard.core.service.CardServiceException,
                       java.security.InvalidKeyException,
                       opencard.core.terminal.CardTerminalException</PRE>
<DL>
<DD>Overloaded method to generate a digital Signature
 that allows to specify the padding algorithm.<DD><DL>
<DT><B>Specified by: </B><DD>signHash in interface opencard.opt.signature.SignatureCardService<DT><B>Throws:</B><DD>java.security.InvalidKeyException - The key type is not supported by the specific card service.<DD>opencard.core.service.CardServiceException - any subclass of CardServiceException<DD>opencard.core.terminal.CardTerminalException - any subclass of CardTerminalException</DL>
</DD>
</DL>
<HR>

<A NAME="signHashInternal(opencard.opt.security.PrivateKeyRef, java.lang.String, java.lang.String, byte[])"><!-- --></A><H3>
signHashInternal</H3>
<PRE>
protected byte[] <B>signHashInternal</B>(opencard.opt.security.PrivateKeyRef&nbsp;privateKey,
                                  java.lang.String&nbsp;signAlgorithm,
                                  java.lang.String&nbsp;padAlgorithm,
                                  byte[]&nbsp;data)
                           throws opencard.core.service.CardServiceException,
                                  java.security.InvalidKeyException,
                                  opencard.core.terminal.CardTerminalException</PRE>
<DL>
<DD>generate signature on the provided hash<DD><DL>
<DT><B>Parameters:</B><DD><CODE>padAlgorithm</CODE> - If specified, check whether the card and the key support the pad algorithm.
                     If not specified, use the key's pad algorithm<DT><B>Throws:</B><DD>java.security.InvalidKeyException - The key type is not supported by the specific card service.<DD>opencard.core.service.CardServiceException - any subclass of CardServiceException<DD>opencard.core.terminal.CardTerminalException - any subclass of CardTerminalException</DL>
</DD>
</DL>
<HR>

<A NAME="verifySignedData(opencard.opt.security.PublicKeyRef, java.lang.String, byte[], byte[])"><!-- --></A><H3>
verifySignedData</H3>
<PRE>
public boolean <B>verifySignedData</B>(opencard.opt.security.PublicKeyRef&nbsp;publicKey,
                                java.lang.String&nbsp;signAlgorithm,
                                byte[]&nbsp;data,
                                byte[]&nbsp;signature)
                         throws opencard.core.service.CardServiceException,
                                java.security.InvalidKeyException,
                                opencard.core.terminal.CardTerminalException</PRE>
<DL>
<DD>Verify a digital Signature including hashing.
 First hash the data, then pad the hash,
 apply the PKA algorithm to the padded hash, then compare the result
 to the provided signature.
 <p>
 The padding algorithm is chosen as defined in the Java Cryptography Architecture Specification.
 <p>
 The standard algorithm name must be specified as defined in the 
 Java Cryptography Architecture API Specification & Reference,
 for example
 <DL COMPACT>
 <DT>MD5withRSA<DD>The Signature algorithm obtained by combining the RSA
                   AsymmetricCipher algorithm with the MD5 MessageDigest Algorithm.
 <DT>MD2withRSA<DD>The Signature algorithm obtained by combining the RSA
                   AsymmetricCipher algorithm with the MD2 MessageDigest Algorithm.
 <DT>SHA1withRSA<DD>The Signature algorithm obtained by combining the RSA
                    AsymmetricCipher algorithm with the SHA-1 MessageDigest Algorithm.
 <DT>SHA1withDSA<DD>Digital Signature Algorithm, as defined in Digital Signature Standard,
                    NIST FIPS 186.  This standard defines a digital signature algorithm
                    that uses the RawDSA asymmetric transformation along with the SHA-1
                    message digest algorithm.
 </DL><DD><DL>
<DT><B>Specified by: </B><DD>verifySignedData in interface opencard.opt.signature.SignatureCardService<DT><B>Parameters:</B><DD><CODE>publicKey</CODE> - a reference to the public key on card to be used for signature validation<DD><CODE>signAlgorithm</CODE> - standard digital signature algorithm name<DD><CODE>data</CODE> - the data for which the signature should be verified<DD><CODE>signature</CODE> - signature to be verified<DT><B>Returns:</B><DD>True if signature valdidation was successfull<DT><B>Throws:</B><DD>java.security.InvalidKeyException - Thrown when the key is not valid or does not match the requested algorithm.<DD>opencard.core.service.CardServiceException - any subclass of CardServiceException<DD>opencard.core.terminal.CardTerminalException - any subclass of CardTerminalException<DT><B>See Also: </B><DD><CODE>JCAStandardNames</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="verifySignedData(opencard.opt.security.PublicKeyRef, java.lang.String, java.lang.String, byte[], byte[])"><!-- --></A><H3>
verifySignedData</H3>
<PRE>
public boolean <B>verifySignedData</B>(opencard.opt.security.PublicKeyRef&nbsp;publicKey,
                                java.lang.String&nbsp;signAlgorithm,
                                java.lang.String&nbsp;padAlgorithm,
                                byte[]&nbsp;data,
                                byte[]&nbsp;signature)
                         throws opencard.core.service.CardServiceException,
                                java.security.InvalidKeyException,
                                opencard.core.terminal.CardTerminalException</PRE>
<DL>
<DD>Verify a digital Signature including hashing
 (overload method that allows to specify the padding algorithm to be used).
 First hash the data, then pad the hash,
 apply the PKA algorithm to the padded hash, then compare the result
 to the provided signature.
 <p>
 The standard algorithm name must be specified as defined in the 
 Java Cryptography Architecture API Specification & Reference,
 for example
 <DL COMPACT>
 <DT>MD5withRSA<DD>The Signature algorithm obtained by combining the RSA
                   AsymmetricCipher algorithm with the MD5 MessageDigest Algorithm.
 <DT>MD2withRSA<DD>The Signature algorithm obtained by combining the RSA
                   AsymmetricCipher algorithm with the MD2 MessageDigest Algorithm.
 <DT>SHA1withRSA<DD>The Signature algorithm obtained by combining the RSA
                    AsymmetricCipher algorithm with the SHA-1 MessageDigest Algorithm.
 <DT>SHA1withDSA<DD>Digital Signature Algorithm, as defined in Digital Signature Standard,
                    NIST FIPS 186.  This standard defines a digital signature algorithm
                    that uses the RawDSA asymmetric transformation along with the SHA-1
                    message digest algorithm.
 </DL><DD><DL>
<DT><B>Specified by: </B><DD>verifySignedData in interface opencard.opt.signature.SignatureCardService<DT><B>Parameters:</B><DD><CODE>publicKey</CODE> - a reference to the public key on card to be used for signature validation<DD><CODE>signAlgorithm</CODE> - standard digital signature algorithm name<DD><CODE>padAlgorithm</CODE> - padding algorithm name, for example one of 
         ISO9796,
         PKCS#1,
         ZEROPADDING<DD><CODE>data</CODE> - the data for which the signature should be verified<DD><CODE>signature</CODE> - signature to be verified<DT><B>Returns:</B><DD>True if signature valdidation was successfull<DT><B>Throws:</B><DD>java.security.InvalidKeyException - Thrown when the key is not valid or does not match the requested algorithm.<DD>opencard.core.service.CardServiceException - any subclass of CardServiceException<DD>opencard.core.terminal.CardTerminalException - any subclass of CardTerminalException<DT><B>See Also: </B><DD><CODE>JCAStandardNames</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="verifySignedDataInternal(opencard.opt.security.PublicKeyRef, java.lang.String, java.lang.String, byte[], byte[])"><!-- --></A><H3>
verifySignedDataInternal</H3>
<PRE>
protected boolean <B>verifySignedDataInternal</B>(opencard.opt.security.PublicKeyRef&nbsp;publicKey,
                                           java.lang.String&nbsp;signAlgorithm,
                                           java.lang.String&nbsp;padAlgorithm,
                                           byte[]&nbsp;data,
                                           byte[]&nbsp;signature)
                                    throws opencard.core.service.CardServiceException,
                                           java.security.InvalidKeyException,
                                           opencard.core.terminal.CardTerminalException</PRE>
<DL>
<DD>calculate hash and verify signature<DD><DL>
<DT><B>Parameters:</B><DD><CODE>padAlgorithm</CODE> - If specified, check whether the card and the key support the pad algorithm.
                     If not specified, use the key's pad algorithm<DT><B>Throws:</B><DD>java.security.InvalidKeyException - The key type is not supported by the specific card service.<DD>opencard.core.service.CardServiceException - any subclass of CardServiceException<DD>opencard.core.terminal.CardTerminalException - any subclass of CardTerminalException</DL>
</DD>
</DL>
<HR>

<A NAME="verifySignedHash(opencard.opt.security.PublicKeyRef, java.lang.String, byte[], byte[])"><!-- --></A><H3>
verifySignedHash</H3>
<PRE>
public boolean <B>verifySignedHash</B>(opencard.opt.security.PublicKeyRef&nbsp;publicKey,
                                java.lang.String&nbsp;signAlgorithm,
                                byte[]&nbsp;hash,
                                byte[]&nbsp;signature)
                         throws opencard.core.service.CardServiceException,
                                java.security.InvalidKeyException,
                                opencard.core.terminal.CardTerminalException</PRE>
<DL>
<DD>Verify a digital Signature.
 Since hashing of large amounts of data may be slow if performed on card
 this method allows to hash outside the card service and just perform
 the signature verificationoperation on card.
 Pad the provided hash,
 apply the PKA algorithm to the padded hash, then compare the result
 to the provided signature.
 <p>
 The padding algorithm is chosen as defined in the Java Cryptography Architecture Specification.
 <p>
 Use a key algorithm name (not a digital signature algorithm name, because digital
 signature algorithms include hashing)
 a defined in the Java Cryptography Architecture API Specification & Reference, 
 for example
 <DL COMPACT>
 <DT>    DSA<DD>  The asymmetric transformation described in NIST FIPS 186, described
                  as the "DSA Sign Operation" and the "DSA Verify Operation", prior to
                  creating a digest.  The input to DSA is always 20 bytes long.

 <DT>    RSA<DD>  The Rivest, Shamir and Adleman AsymmetricCipher algorithm. RSA
                  Encryption as defined in the RSA Laboratory Technical Note PKCS#1.
 </DL><DD><DL>
<DT><B>Specified by: </B><DD>verifySignedHash in interface opencard.opt.signature.SignatureCardService<DT><B>Parameters:</B><DD><CODE>publicKey</CODE> - a reference to the public key on card to be used for signature validation<DD><CODE>signAlgorithm</CODE> - standard key algorithm name<DD><CODE>hash</CODE> - The hash for which the signature should be verified.<DD><CODE>signature</CODE> - signature to be verified<DT><B>Returns:</B><DD>True if signature valdidation was successfull<DT><B>Throws:</B><DD>java.security.InvalidKeyException - Thrown when the key is not valid or does not match the requested algorithm.<DD>opencard.core.service.CardServiceException - any subclass of CardServiceException<DD>opencard.core.terminal.CardTerminalException - any subclass of CardTerminalException<DT><B>See Also: </B><DD><CODE>JCAStandardNames</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="verifySignedHash(opencard.opt.security.PublicKeyRef, java.lang.String, java.lang.String, byte[], byte[])"><!-- --></A><H3>
verifySignedHash</H3>
<PRE>
public boolean <B>verifySignedHash</B>(opencard.opt.security.PublicKeyRef&nbsp;publicKey,
                                java.lang.String&nbsp;signAlgorithm,
                                java.lang.String&nbsp;padAlgorithm,
                                byte[]&nbsp;hash,
                                byte[]&nbsp;signature)
                         throws opencard.core.service.CardServiceException,
                                java.security.InvalidKeyException,
                                opencard.core.terminal.CardTerminalException</PRE>
<DL>
<DD>Verify a digital Signature
 (overloaded method that allows to specify the padding algorithm to be used).
 Since hashing of large amounts of data may be slow if performed on card
 this method allows to hash outside the card service and just perform
 the signature verification operation on card.
 Pad the provided hash,
 apply the PKA algorithm to the padded hash, then compare the result
 to the provided signature.
 <p>
 Use a key algorithm name (not a digital signature algorithm name, because digital
 signature algorithms include hashing)
 a defined in the Java Cryptography Architecture API Specification & Reference, 
 for example
 <DL COMPACT>
 <DT>    DSA<DD>  The asymmetric transformation described in NIST FIPS 186, described
                  as the "DSA Sign Operation" and the "DSA Verify Operation", prior to
                  creating a digest.  The input to DSA is always 20 bytes long.

 <DT>    RSA<DD>  The Rivest, Shamir and Adleman AsymmetricCipher algorithm. RSA
                  Encryption as defined in the RSA Laboratory Technical Note PKCS#1.
 </DL><DD><DL>
<DT><B>Specified by: </B><DD>verifySignedHash in interface opencard.opt.signature.SignatureCardService<DT><B>Parameters:</B><DD><CODE>publicKey</CODE> - a reference to the public key on card to be used for signature validation<DD><CODE>signAlgorithm</CODE> - standard key algorithm name<DD><CODE>padAlgorithm</CODE> - padding algorithm name, for example one of 
         ISO9796,
         PKCS#1,
         ZEROPADDING<DD><CODE>hash</CODE> - The hash for which the signature should be verified.<DD><CODE>signature</CODE> - signature to be verified<DT><B>Returns:</B><DD>True if signature valdidation was successfull<DT><B>Throws:</B><DD>java.security.InvalidKeyException - Thrown when the key is not valid or does not match the requested algorithm.<DD>opencard.core.service.CardServiceException - any subclass of CardServiceException<DD>opencard.core.terminal.CardTerminalException - any subclass of CardTerminalException<DT><B>See Also: </B><DD><CODE>JCAStandardNames</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="verifySignedHashInternal(opencard.opt.security.PublicKeyRef, java.lang.String, java.lang.String, byte[], byte[])"><!-- --></A><H3>
verifySignedHashInternal</H3>
<PRE>
protected boolean <B>verifySignedHashInternal</B>(opencard.opt.security.PublicKeyRef&nbsp;publicKey,
                                           java.lang.String&nbsp;signAlgorithm,
                                           java.lang.String&nbsp;padAlgorithm,
                                           byte[]&nbsp;hash,
                                           byte[]&nbsp;signature)
                                    throws opencard.core.service.CardServiceException,
                                           java.security.InvalidKeyException,
                                           opencard.core.terminal.CardTerminalException</PRE>
<DL>
<DD>verify signature for given hash<DD><DL>
<DT><B>Parameters:</B><DD><CODE>padAlgorithm</CODE> - If specified, check whether the card and the key support the pad algorithm.
                     If not specified, use the key's pad algorithm<DT><B>Throws:</B><DD>java.security.InvalidKeyException - The key type is not supported by the specific card service.<DD>opencard.core.service.CardServiceException - any subclass of CardServiceException<DD>opencard.core.terminal.CardTerminalException - any subclass of CardTerminalException</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" ID="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT ID="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="package-summary.html"><FONT ID="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" ID="NavBarCell1Rev"> &nbsp;<FONT ID="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="package-tree.html"><FONT ID="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT ID="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT ID="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" ID="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT ID="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" ID="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../com/ibm/opencard/signature/MFCSignatureParameter.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" ID="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="MFCSignatureService.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" ID="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" ID="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
