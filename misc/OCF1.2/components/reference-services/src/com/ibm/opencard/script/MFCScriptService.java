/*
 * Copyright © 1997 - 1999 IBM Corporation.
 * 
 * Redistribution and use in source (source code) and binary (object code)
 * forms, with or without modification, are permitted provided that the
 * following conditions are met:
 * 1. Redistributed source code must retain the above copyright notice, this
 * list of conditions and the disclaimer below.
 * 2. Redistributed object code must reproduce the above copyright notice,
 * this list of conditions and the disclaimer below in the documentation
 * and/or other materials provided with the distribution.
 * 3. The name of IBM may not be used to endorse or promote products derived
 * from this software or in any other form without specific prior written
 * permission from IBM.
 * 4. Redistribution of any modified code must be labeled "Code derived from
 * the original OpenCard Framework".
 * 
 * THIS SOFTWARE IS PROVIDED BY IBM "AS IS" FREE OF CHARGE. IBM SHALL NOT BE
 * LIABLE FOR INFRINGEMENTS OF THIRD PARTIES RIGHTS BASED ON THIS SOFTWARE.  ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IBM DOES NOT WARRANT THAT THE FUNCTIONS CONTAINED IN THIS
 * SOFTWARE WILL MEET THE USER'S REQUIREMENTS OR THAT THE OPERATION OF IT WILL
 * BE UNINTERRUPTED OR ERROR-FREE.  IN NO EVENT, UNLESS REQUIRED BY APPLICABLE
 * LAW, SHALL IBM BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ALSO, IBM IS UNDER NO OBLIGATION
 * TO MAINTAIN, CORRECT, UPDATE, CHANGE, MODIFY, OR OTHERWISE SUPPORT THIS
 * SOFTWARE.
 */

package com.ibm.opencard.script;


import java.util.Vector;
import java.util.Enumeration;
import java.util.StringTokenizer;

import opencard.core.service.SmartCard;
import opencard.core.service.CardServiceScheduler;
import opencard.core.service.CardServiceException;
import opencard.core.terminal.CommandAPDU;
import opencard.core.terminal.ResponseAPDU;
import opencard.core.terminal.CardTerminalException;
import opencard.core.util.Tracer;

import opencard.opt.util.TLV;

import com.ibm.opencard.service.MFCCardChannel;
import com.ibm.opencard.service.MFCCardService;
import com.ibm.opencard.service.MFCCardServiceParameter;
import com.ibm.opencard.service.MFCGenericFactory;

import com.ibm.opencard.handler.ServiceProvider;
import com.ibm.opencard.handler.Handler;
import com.ibm.opencard.handler.HandlerChain;

import com.ibm.opencard.dictionary.Dictionary;
import com.ibm.opencard.buffer.TLVBuffer;


/**
 * A card service executing scripts generated by IBM's smart card toolkit.
 * This script card service uses handlers to execute most of the requests
 * composing a script. The requests handled directly here are those to
 * execute a procedure defined in the script, and those to send an APDU to
 * the smartcard. The handlers that execute the rest of the orders have to
 * do their job themselfes, or may use a card service that is an instance
 * of <tt>MFCCardService</tt>. This restriction is the reason for the MFC
 * prefix in the class name.
 *
 * @version $Id: MFCScriptService.java,v 1.5 1999/03/22 09:41:17 rweber Exp $
 *
 * @author Roland Weber (rolweber@de.ibm.com)
 */
public class MFCScriptService extends MFCCardService
    implements ServiceProvider, APDUSender
{
  /** A tracer for debugging output. */
  private final static Tracer ctracer = new Tracer(MFCScriptService.class);


  /**
   * The smartcard to support by this service.
   * This attribute is also defined in the indirect base
   * class <tt>CardService</tt>. It is needed here to obtain
   * the card services for handlers in <tt>getService</tt>.
   *
   * @see opencard.core.service.CardService
   * @see #getService
   */
  private SmartCard smart_card;


  /**
   * Whether this service shall operate blocking.
   * This attribute is also defined in the indirect base class
   * <tt>CardService</tt>. It is needed here to make sure that
   * the card services for the handlers, which are obtained by
   * <tt>getService</tt>, operate in the same mode.
   *
   * @see opencard.core.service.CardService
   * @see #getService
   */
  private boolean is_blocking;


  /**
   * The chain of handlers for the various requests in a script.
   * This chain is initialized in <tt>initHandlerChain</tt>.
   *
   * @see #initHandlerChain
   */
  private HandlerChain handler_chain = null;


  /**
   * The default handlers used when no property has been set for them.
   * This attribute is the default value for the property
   * <tt>OpenCard.IBM.Handler</tt>. It holds the fully qualified class
   * names for all handlers that should be put into a handler chain,
   * separated by whitespace.
   */
  private final String default_handlers = // note the separating whitespace
    "com.ibm.opencard.handler.FileHandler"           + " " +
    "com.ibm.opencard.handler.SignatureHandler"      + " " +
    "com.ibm.opencard.handler.IdentificationHandler" + " " +
    "com.ibm.opencard.handler.ImportExportHandler"   + " " +
    "com.ibm.opencard.handler.CryptoHandler"         ;


  /**
   * A collection of the services requested by the handlers.
   *
   * @see #getService
   */
  private Vector child_services = null;


  // construction /////////////////////////////////////////////////////////////


  /**
   * Default constructor.
   * Before the created service can actually be used, <tt>initialize</tt>
   * has to be invoked.
   *
   * @see #initialize
   */
  public MFCScriptService()
  {
    handler_chain  = new HandlerChain();
    child_services = new Vector();
  }


  /**
   * Initializes this script card service.
   * This method invokes <tt>initGeneric</tt> in the base class.
   * Then, it instantiates the handler chain. Note that the base
   * class will not be fully initialized. The select operation
   * defined there will not be available for this service.
   *
   * @param scheduler   where to allocate channels
   * @param smartcard   which smartcard to contact
   * @param blocking    whether operation shall be blocking
   *
   * @exception CardServiceException   never thrown
   *
   * @see com.ibm.opencard.service.MFCCardService#initialize
   * @see #initHandlerChain
   */
  protected void initialize(CardServiceScheduler scheduler,
                            SmartCard            smartcard,
                            boolean              blocking )
       throws CardServiceException
  {
    smart_card  = smartcard;
    is_blocking = blocking;

    MFCGenericFactory.customizeScheduler(scheduler);

    // The parameter for initializing the base class is not fully
    // prepared. Namely, it is missing a card service implementation
    // and a select response parser. This means the SELECT command
    // defined in the base class is not available. That is no problem,
    // since this is a meta service that requires only channel and
    // credential management, no actual commands.

    MFCCardServiceParameter csp = new MFCCardServiceParameter(scheduler,
                                                              smartcard,
                                                              blocking );
    super.initGeneric(csp);

    initHandlerChain();
  }


  /**
   * Initializes the handler chain of this script card service.
   * The handlers are needed for most of the request types that can be
   * found in a script. The handlers that should be instantiated can
   * be specified in the property <tt>OpenCard.IBM.Handler</tt>. The
   * default value for this property is defined in <tt>default_handlers</tt>.
   * <br>
   * If handlers to be loaded cannot be initialized, this is reported
   * via the trace mechanism. However, no exception is thrown and no
   * other kind of error is reported, since this script service may be
   * able to execute a script anyway, if that script does not contain
   * requests for which the missing handlers are needed.
   * <br>
   * Of course, the reasons for this error behavior includes the US export
   * restrictions. There is a handler for cryptographic operations, which
   * may not be exported.
   *
   * @see #default_handlers
   */
  protected final void initHandlerChain()
  {
    ctracer.debug("initHandlerChain", "loading properties");
    String name = "OpenCard.IBM.Handler";
    String prop = System.getProperty(name, default_handlers);

    if (prop == null)
      return;

    int pos = 0;
    StringTokenizer stok = new StringTokenizer(prop);
    while (stok.hasMoreElements())
      {
        String classname = (String) stok.nextElement();
        ctracer.debug("initHandlerChain", classname);

        try {
          Class clazz = Class.forName(classname);
          Handler  h  = (Handler) clazz.newInstance();
          handler_chain.addAt(h, pos);
          pos++;

        } catch (Exception e) {
          ctracer.info("initHandlerChain", e);
        } catch (Error e) {
          ctracer.info("initHandlerChain", e);
        }
      }

  } // initHandlerChain



  // service //////////////////////////////////////////////////////////////////


  /**
   * Allocates a card channel.
   * The channel is passed to all child services that have been allocated
   * by the handlers.
   */
  protected void allocateChannel()
  {
    allocateCardChannel();
    MFCCardChannel channel = getMFCChannel();
    Enumeration   children = child_services.elements();
    while (children.hasMoreElements())
      {
        MFCCardService child = (MFCCardService) children.nextElement();
        child.setParentChannel(channel);
      }
  }


  /**
   * Releases a card channel.
   * All child services are informed that the channel is no longer allocated.
   */
  protected void releaseChannel()
  {
    Enumeration children = child_services.elements();
    while (children.hasMoreElements())
      {
        MFCCardService child = (MFCCardService) children.nextElement();
        child.setParentChannel(null);
      }
    releaseCardChannel();
  }


  /**
   * Returns a MFC card service of the requested class.
   * The service is registered, and will be prepared for use before the
   * handler chain is invoked. This method is meant to be invoked only
   * by the handlers in the handler chain of this service.
   * <br>
   * If the requested service interface is <tt>APDUSender</tt>, or any
   * other class implemented by this script service, a reference to
   * <tt>this</tt> is returned.
   *
   * @param clazz    the class of the requested service, has to be
   *                 a subclass of <tt>MFCCardService</tt>
   * @return    an instance of the requested MFC card service,
   *            or <tt>null</tt> if it could not be found
   *
   * @exception CardServiceException
   *            if the requested service was found, but could not be obtained
   *
   * @see com.ibm.opencard.handler.APDUSender
   */
  public MFCCardService getService(Class clazz)
       throws CardServiceException
  {
    MFCCardService service = null;

    if (clazz.isAssignableFrom(MFCScriptService.class))
      service = this;
    else try {
      service = (MFCCardService) smart_card.getCardService(clazz, is_blocking);
    } catch (ClassNotFoundException cnf) {
      // just return null
    }

    return service;
  }


  /**
   * Sends a command to the smartcard and returns the response.
   * This method is required by the interface <tt>APDUSender</tt>.
   * It should only be invoked by the handlers in the handler chain,
   * and only while a script is executed.
   *
   * @param command     the command to send to the smartcard
   * @return            the response from the smartcard
   *
   * @exception CardTerminalException
   *            the underlying terminal encountered an error when
   *            communicating with the smartcard
   *
   * @see com.ibm.opencard.handler.APDUSender
   */
  final public ResponseAPDU sendCommand(CommandAPDU command)
       throws CardTerminalException
  {
    return getCardChannel().sendCommandAPDU(command);
  }


  /**
   * Executes a given order within a script.
   * Optionally, a dictionary and a blackboard can be passed.
   *
   * @param order      the name of the script procedure to be executed
   * @param script     the script containing the procedure that shall be
   *                   executed, and all subprocedures invoked from there
   * @param dictionary the dictionary to be used, <tt>null</tt> if none
   * @param blackboard the blackbaord to be used, <tt>null</tt> if none
   *
   * @exception CardServiceException
   *            if an error was encountered while interpreting the script
   *            or while trying to handle a request in the script
   * @exception CardTerminalException
   *            if the terminal encountered an error while communicating with
   *            the smartcard in order to execute a request in the script
   *
   * @author Thomas Schaeck (schaeck@de.ibm.com)
   * @author Roland Weber  (rolweber@de.ibm.com)
   */
  public void executeOrder(String     order,
                           Script     script,
                           Dictionary dictionary,
                           TLVBuffer  blackboard)
       throws CardServiceException, CardTerminalException
  {
    ScriptInterpreter si = new ScriptInterpreter(handler_chain, this);
    try {
      allocateChannel();
      si.executeOrder(order, script, dictionary, blackboard);
    } finally {
      releaseChannel();
    }
  } // executeOrder


} // class MFCScriptService
